package main

import (
	"context"
	"fmt"
	"io"
	"os"

	"github.com/go-redis/redis/v8"
	log "github.com/sirupsen/logrus"

	"rkn-rejects/internal/fw"
)

func fPuts(fd io.Writer, f string, s ...interface{}) {
	if _, err := fmt.Fprintf(fd, f, s...); err != nil {
		log.Panicln("can't write to file ", err)
	}
}

func dumpIpsToFile(fileName, tableName, setName string) {
	rdb := redis.NewClient(&redis.Options{
		Addr: fmt.Sprintf("%s:%d",
			CFG.Parse.Redis.Host,
			CFG.Parse.Redis.Port),
		Password: CFG.Parse.Redis.Password,
		DB:       CFG.Parse.Redis.Db,
	})
	defer func() {
		if err := rdb.Close(); err != nil {
			log.Panicln("close redis conn", err)
		}
	}()

	ctx := context.Background()
	res, err := rdb.SMembers(ctx, "ip").Result()
	if err != nil {
		log.Panicln("redis get ip members", err)
	}

	fd, err := os.Create(fileName)
	if err != nil {
		log.Panicln("create nft file", err)
	}
	defer func() {
		if err := fd.Close(); err != nil {
			log.Errorln("can't close nft file", err)
		}
	}()

	fPuts(fd, "#!/usr/sbin/nft -f \n\n")
	fPuts(fd, "# this file generated by the get-rkn tool \n\n")
	fPuts(fd, "flush set %s %s \n\n", tableName, setName)
	fPuts(fd, "add element %s %s {\n", tableName, setName)
	for _, ip := range res {
		fPuts(fd, "    %s,\n", ip)
	}
	fPuts(fd, "}")
}

func ip2nft() {
	log.Info("gen deny by ip nftables rules")
	dumpIpsToFile(CFG.Fw.IpDenyFile, CFG.Fw.IpDenyTable, CFG.Fw.IpDenySet)

	log.Info("apply nftables rules")
	if err := fw.FlushSet(CFG.Fw.IpDenyTable, CFG.Fw.IpDenySet); err != nil {
		log.Panicf("nft flush %s %s: %v",
			CFG.Fw.IpDenyTable, CFG.Fw.IpDenySet, err)
	}
	if err := fw.Apply(CFG.Fw.IpDenyFile); err != nil {
		log.Panicln("apply nft", CFG.Fw.IpDenyFile, err)
	}
}
